https://www.youtube.com/watch?v=6Aqxv29RGPc&list=PLu0W_9lII9ahIappRPN0MCAgtOu3lQjQi&index=58


1. Recursively divide the array unless u have a single element left
2. Keep merging as u move up

Time:O(nlog n), Space:O(N) not in place.
-Stable
-Not adaptive (will run if if the array is sorted)



#include<vector>

using namespace std;

void merge(int arr[], int l, int mid, int h)
{
    int* b=new int[h-l+1];              //every merge call, we create a temp array same as the size of array we have to merge and at the end we copy its content to the orignal array
    
    int i=l,j=mid+1,k=l;                  //IMP  ---> i and k will start from l
    
    while(i<=mid && j<=h)
    {
        if(arr[i]<arr[j])
        {
            b[k]=arr[i];
            i++;
            k++;
        }
        else
        {
            b[k]=arr[j];
            j++;
            k++;
        }
    }
    
    while(i<=mid )
    {
        b[k]=arr[i];
        i++;
        k++;
       
    }
    
    while(j<=h)
    {
        b[k]=arr[j];
        j++;
        k++;
        
    }
    
    for(int i=l;i<=h;i++) 
    {
        arr[i]=b[i];                 //copy contents of temp array to orignal array
    }
}


void mergesort(int arr[], int l, int h)
{
    int mid;
    if(l<h)
    {
        mid=(l+h)/2;
        mergesort(arr,l,mid);       O(log n)
        mergesort(arr,mid+1,h);      O(log n)
        merge(arr,l,mid,h);          O(n), compare every element and copy into new array
    }
}


int main()
{
    int arr[]={10,4,56,23,7,1};
    int n=sizeof(arr)/sizeof(arr[0]);
    mergesort(arr,0,n-1);
    for(int i=0;i<n;i++)
    {
        cout<<arr[i]<<" ";
    }
    

    return 0;
}
