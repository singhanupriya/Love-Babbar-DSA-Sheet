https://www.geeksforgeeks.org/minimum-removals-array-make-max-min-k/

1. U have to find min and max of array and make sure max-min<=k.
2. Sort the array first else u have to iterate every time to find min or max.
3. If max-min<=k return 0 moves
    else u can either remove min or max return 1[1 move as one element removed] + min(solve(arr,i+1,j,k-- min remved ),solve(arr,i,j-1,k-- max remved)
    
   i=0 and j=n-1


int solve(int i, int j, int k, vector<int>& a,vector<vector<int>>& dp)
    {
        if(i>=j)
        {
            return 0; //if one element, diff=0, no removal
        }
        
        if(a[j]-a[i]<=k)
        {
            return 0;
        }
        
        if(dp[i][j]!=-1)
        {
            return dp[i][j];
        }
        
        int removeStart=solve(i+1,j,k,a,dp);
        int removeEnd=solve(i,j-1,k,a,dp);
        
        return dp[i][j]=1+min(removeStart,removeEnd);
    }
    
        
    
    int removals(vector<int>& a, int k){
        //Code here
        
        sort(a.begin(),a.end());
        int n=a.size();
        vector<vector<int>> dp(n,vector<int>(n,-1));
        
        
        return solve(0,n-1,k,a,dp);
        
    }
};



Method 2:

Time:O(N^2), Space:O(N^2)

int removals(vector<int>& a, int k){
        //Code here
        
        sort(a.begin(),a.end());
        int n=a.size();
        
        //since here, i and j are on the same string, we have to use len like in
        //pallindromic sustring
        
        //len goes from 0 to n
        
        //i,j ->index goes from 0 to n-1
        
        //i->startIndex,j->endINdex
        
        vector<vector<int>> dp(n,vector<int>(n,0));
        
        
        for(int i=0;i<n;i++)
        {
            dp[i][i]=0; //length 1 ans is 0 removals
        }
        
        for(int len=2;len<=n;len++)
        {
            for(int startIndex=0;startIndex<=n-len;startIndex++)
            {
                int endIndex=startIndex+len-1;
                
                if(a[endIndex]-a[startIndex]<=k)
                {
                    dp[startIndex][endIndex]=0;
                }
                else
                {
                    dp[startIndex][endIndex]=1 + min(dp[startIndex+1][endIndex],dp[startIndex][endIndex-1]);
                    
                }
                
                
            }
        }
        
        
        return dp[0][n-1];
        
    }
